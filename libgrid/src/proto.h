cgrid1d *cgrid1d_alloc(long nx, double step, double complex (*value_outside)(const cgrid1d *grid, long i), void *outside_params_ptr) ;
void cgrid1d_free(cgrid1d *grid) ;
void cgrid1d_write(cgrid1d *grid, FILE *out) ;
void cgrid1d_read(cgrid1d *grid, FILE *in) ;
void cgrid1d_copy(cgrid1d *copy, const cgrid1d *grid) ;
void cgrid1d_conjugate(cgrid1d *conjugate, const cgrid1d *grid) ;
void cgrid1d_shift(cgrid1d *shifted, const cgrid1d *grid, double x) ;
void cgrid1d_zero(cgrid1d *grid) ; 
void cgrid1d_constant(cgrid1d *grid, double complex c) ;
void cgrid1d_map(cgrid1d *grid, double complex (*func)(void *arg, double x), void *farg) ;
void cgrid1d_smooth_map(cgrid1d *grid, double complex (*func)(void *arg, double x), void *farg, int ns) ;
void cgrid1d_adaptive_map(cgrid1d *grid, double complex (*func)(void *arg, double x), void *farg, int min_ns, int max_ns, double tol) ;
void cgrid1d_sum(cgrid1d *gridc, const cgrid1d *grida, const cgrid1d *gridb) ;
void cgrid1d_difference(cgrid1d *gridc, const cgrid1d *grida, const cgrid1d *gridb) ;
void cgrid1d_product(cgrid1d *gridc, const cgrid1d *grida, const cgrid1d *gridb) ;
void cgrid1d_power(cgrid1d *gridb, const cgrid1d *grida, double exponent) ;
void cgrid1d_abs_power(cgrid1d *gridb, const cgrid1d *grida, double exponent) ;
void cgrid1d_division(cgrid1d *gridc, const cgrid1d *grida, const cgrid1d *gridb) ;
void cgrid1d_conjugate_product(cgrid1d *gridc, const cgrid1d *grida, const cgrid1d *gridb) ;
void cgrid1d_add(cgrid1d *grid, double complex c) ;
void cgrid1d_multiply(cgrid1d *grid, double complex c) ;
void cgrid1d_add_and_multiply(cgrid1d *grid, double complex ca, double complex cm) ;
void cgrid1d_multiply_and_add(cgrid1d *grid, double complex cm, double complex ca) ;
void cgrid1d_add_scaled(cgrid1d *gridc, double complex d, const cgrid1d *grida) ;
void cgrid1d_add_scaled_product(cgrid1d *gridc, double complex d, const cgrid1d *grida, const cgrid1d *gridb) ;
void cgrid1d_operate_one(cgrid1d *gridc, const cgrid1d *grida, double complex (*operator)(double complex a)) ;
void cgrid1d_operate_two(cgrid1d *gridc, const cgrid1d *grida, const cgrid1d *gridb, double complex (*operator)(double complex a, double complex b)) ;
void cgrid1d_transform_one(cgrid1d *grid, void (*operator)(double complex *a)) ;
void cgrid1d_transform_two(cgrid1d *grida, cgrid1d *gridb, void (*operator)(double complex *a, double complex *b)) ;
double complex cgrid1d_integral(const cgrid1d *grid) ;
double complex cgrid1d_integral_region(const cgrid1d *grid, double xl, double xu) ;
double cgrid1d_integral_of_square(const cgrid1d *grid) ;
double complex cgrid1d_integral_of_conjugate_product(const cgrid1d *grida, const cgrid1d *gridb) ;
double complex cgrid1d_grid_expectation_value(const cgrid1d *grida, const cgrid1d *gridb) ;
double complex cgrid1d_grid_expectation_value_func(void *arg, double complex (*func)(void *arg, double complex val, double x), const cgrid1d *grida) ;
double complex cgrid1d_weighted_integral(const cgrid1d *grid, double complex (*weight)(void *farg, double x), void *farg) ;
double cgrid1d_weighted_integral_of_square(const cgrid1d *grid, double (*weight)(void *farg, double x), void *farg) ;
void cgrid1d_fd_gradient(const cgrid1d *grid, cgrid1d *gradient) ;
void cgrid1d_fd_gradient_x(const cgrid1d *grid, cgrid1d *gradient) ;
void cgrid1d_fd_laplace(const cgrid1d *grid, cgrid1d *laplace) ;
void cgrid1d_fd_gradient_dot_gradient(const cgrid1d *grid, cgrid1d *grad_dot_grad);
void cgrid1d_print(const cgrid1d *grid, FILE *out) ;
void cgrid1d_fft(cgrid1d *grid) ;
void cgrid1d_fourier_transform(cgrid1d *grid) ;
void cgrid1d_inverse_fft(cgrid1d *grid) ;
void cgrid1d_scaled_inverse_fft(cgrid1d *grid, double complex c) ;
void cgrid1d_inverse_fft_norm(cgrid1d *grid) ;
void cgrid1d_inverse_fourier_transform(cgrid1d *grid) ;
void cgrid1d_fft_convolute(cgrid1d *gridc, const cgrid1d *grida, const cgrid1d *gridb) ;
void cgrid1d_fft_gradient(const cgrid1d *grid, cgrid1d *gradient_x) ;
void cgrid1d_fft_gradient_x(const cgrid1d *grid, cgrid1d *gradient_x) ;
void cgrid1d_fft_laplace(const cgrid1d *grid, cgrid1d *laplace) ;
double cgrid1d_fft_laplace_expectation_value(const cgrid1d *grid, cgrid1d *laplace) ;
double complex cgrid1d_value_outside_constantdirichlet(const cgrid1d *grid, long i) ;
double complex cgrid1d_value_outside_neumann(const cgrid1d *grid, long i) ;
double complex cgrid1d_value_outside_periodic(const cgrid1d *grid, long i) ;
inline double complex cgrid1d_value_at_index(const cgrid1d *grid, long i) ;
inline double complex cgrid1d_value(const cgrid1d *grid, double x) ;
void cgrid1d_extrapolate(cgrid1d *dest, cgrid1d *src) ;
void cgrid1d_zero_re(cgrid1d *grid) ;
void cgrid1d_zero_im(cgrid1d *grid) ;
void cgrid1d_fftw_alloc(cgrid1d *grid) ;
void cgrid1d_fftw_free(cgrid1d *grid) ;
void cgrid1d_fftw(cgrid1d *grid) ;
void cgrid1d_fftw_inv(cgrid1d *grid) ;
cgrid2d *cgrid2d_alloc(long nx, long ny, double step, double complex (*value_outside)(const cgrid2d *grid, long i, long j), void *outside_params_ptr) ;
void cgrid2d_free(cgrid2d *grid) ;
void cgrid2d_write(cgrid2d *grid, FILE *out) ;
void cgrid2d_read(cgrid2d *grid, FILE *in) ;
void cgrid2d_copy(cgrid2d *copy, const cgrid2d *grid) ;
void cgrid2d_conjugate(cgrid2d *conjugate, const cgrid2d *grid) ;
void cgrid2d_shift(cgrid2d *shifted, const cgrid2d *grid, double x, double y) ;
void cgrid2d_zero(cgrid2d *grid) ; 
void cgrid2d_constant(cgrid2d *grid, double complex c) ;
void cgrid2d_product_func(cgrid2d *grid, double complex (*func)(void *arg, double x, double y), void *farg) ;
void cgrid2d_map(cgrid2d *grid, double complex (*func)(void *arg, double x, double y), void *farg) ;
void cgrid2d_smooth_map(cgrid2d *grid, double complex (*func)(void *arg, double x, double y), void *farg, int ns) ;
void cgrid2d_adaptive_map(cgrid2d *grid, double complex (*func)(void *arg, double x, double y), void *farg, int min_ns, int max_ns, double tol) ;
void cgrid2d_sum(cgrid2d *gridc, const cgrid2d *grida, const cgrid2d *gridb) ;
void cgrid2d_difference(cgrid2d *gridc, const cgrid2d *grida, const cgrid2d *gridb) ;
void cgrid2d_product(cgrid2d *gridc, const cgrid2d *grida, const cgrid2d *gridb) ;
void cgrid2d_power(cgrid2d *gridb, const cgrid2d *grida, double exponent) ;
void cgrid2d_abs_power(cgrid2d *gridb, const cgrid2d *grida, double exponent) ;
void cgrid2d_division(cgrid2d *gridc, const cgrid2d *grida, const cgrid2d *gridb) ;
void cgrid2d_conjugate_product(cgrid2d *gridc, const cgrid2d *grida, const cgrid2d *gridb) ;
void cgrid2d_add(cgrid2d *grid, double complex c) ;
void cgrid2d_multiply(cgrid2d *grid, double complex c) ;
void cgrid2d_add_and_multiply(cgrid2d *grid, double complex ca, double complex cm) ;
void cgrid2d_multiply_and_add(cgrid2d *grid, double complex cm, double complex ca) ;
void cgrid2d_add_scaled(cgrid2d *gridc, double complex d, const cgrid2d *grida) ;
void cgrid2d_add_scaled_product(cgrid2d *gridc, double complex d, const cgrid2d *grida, const cgrid2d *gridb) ;
void cgrid2d_operate_one(cgrid2d *gridc, const cgrid2d *grida, double complex (*operator)(double complex a)) ;
void cgrid2d_operate_two(cgrid2d *gridc, const cgrid2d *grida, const cgrid2d *gridb, double complex (*operator)(double complex a, double complex b)) ;
void cgrid2d_transform_one(cgrid2d *grid, void (*operator)(double complex *a)) ;
void cgrid2d_transform_two(cgrid2d *grida, cgrid2d *gridb, void (*operator)(double complex *a, double complex *b)) ;
double complex cgrid2d_integral(const cgrid2d *grid) ;
double complex cgrid2d_integral_region(const cgrid2d *grid, double xl, double xu, double yl, double yu) ;
double cgrid2d_integral_of_square(const cgrid2d *grid) ;
double complex cgrid2d_integral_of_conjugate_product(const cgrid2d *grida, const cgrid2d *gridb) ;
double complex cgrid2d_grid_expectation_value(const cgrid2d *grida, const cgrid2d *gridb) ;
double complex cgrid2d_grid_expectation_value_func(void *arg, double complex (*func)(void *arg, double complex val, double x, double y), const cgrid2d *grida) ;
double complex cgrid2d_weighted_integral(const cgrid2d *grid, double complex (*weight)(void *farg, double x, double y), void *farg) ;
double cgrid2d_weighted_integral_of_square(const cgrid2d *grid, double (*weight)(void *farg, double x, double y), void *farg) ;
void cgrid2d_fd_gradient_x(const cgrid2d *grid, cgrid2d *gradient) ;
void cgrid2d_fd_gradient_y(const cgrid2d *grid, cgrid2d *gradient) ;
void cgrid2d_fd_gradient(const cgrid2d *grid, cgrid2d *gradient_x, cgrid2d *gradient_y) ;
void cgrid2d_fd_laplace(const cgrid2d *grid, cgrid2d *laplace) ;
void cgrid2d_fd_gradient_dot_gradient(const cgrid2d *grid, cgrid2d *grad_dot_grad) ;
void cgrid2d_print(const cgrid2d *grid, FILE *out) ;
void cgrid2d_fft(cgrid2d *grid) ;
void cgrid2d_fourier_transform(cgrid2d *grid) ;
void cgrid2d_inverse_fft(cgrid2d *grid) ;
void cgrid2d_scaled_inverse_fft(cgrid2d *grid, double complex c) ;
void cgrid2d_inverse_fft_norm(cgrid2d *grid) ;
void cgrid2d_inverse_fourier_transform(cgrid2d *grid) ;
void cgrid2d_fft_convolute(cgrid2d *gridc, const cgrid2d *grida, const cgrid2d *gridb) ;
void cgrid2d_fft_gradient_x(const cgrid2d *grid, cgrid2d *gradient_x) ;
void cgrid2d_fft_gradient_y(const cgrid2d *grid, cgrid2d *gradient_y) ;
void cgrid2d_fft_gradient(const cgrid2d *grid, cgrid2d *gradient_x, cgrid2d *gradient_y) ;
void cgrid2d_fft_laplace(const cgrid2d *grid, cgrid2d *laplace)  ;
double cgrid2d_fft_laplace_expectation_value(const cgrid2d *grid, cgrid2d *laplace)  ;
double complex cgrid2d_value_outside_constantdirichlet(const cgrid2d *grid, long i, long j) ;
double complex cgrid2d_value_outside_neumann(const cgrid2d *grid, long i, long j) ;
double complex cgrid2d_value_outside_periodic(const cgrid2d *grid, long i, long j) ;
inline double complex cgrid2d_value_at_index(const cgrid2d *grid, long i, long j) ;
inline double complex cgrid2d_value(const cgrid2d *grid, double x, double y) ;
void cgrid2d_extrapolate(cgrid2d *dest, cgrid2d *src) ;
void cgrid2d_zero_re(cgrid2d *grid) ;
void cgrid2d_zero_im(cgrid2d *grid) ;
void cgrid2d_product_func_cyl(cgrid2d *grid, double complex (*func)(void *arg, double z, double r), void *farg) ;
void cgrid2d_map_cyl(cgrid2d *grid, double complex (*func)(void *arg, double z, double r), void *farg) ;
void cgrid2d_smooth_map_cyl(cgrid2d *grid, double complex (*func)(void *arg, double z, double r), void *farg, int ns) ;
void cgrid2d_adaptive_map_cyl(cgrid2d *grid, double complex (*func)(void *arg, double z, double r), void *farg, int min_ns, int max_ns, double tol) ;
double complex cgrid2d_integral_cyl(const cgrid2d *grid) ;
double cgrid2d_integral_of_square_cyl(const cgrid2d *grid) ;
double complex cgrid2d_grid_expectation_value_cyl(const cgrid2d *grida, const cgrid2d *gridb) ;
double complex cgrid2d_grid_expectation_value_func_cyl(void *arg, double complex (*func)(void *arg, double complex val, double z, double r), const cgrid2d *grida) ;
double complex cgrid2d_weighted_integral_cyl(const cgrid2d *grid, double complex (*weight)(void *farg, double z, double r), void *farg) ;
double cgrid2d_weighted_integral_of_square_cyl(const cgrid2d *grid, double complex (*weight)(void *farg, double z, double r), void *farg) ;
void cgrid2d_fd_gradient_z_cyl(const cgrid2d *grid, cgrid2d *gradient) ;
void cgrid2d_fd_gradient_r_cyl(const cgrid2d *grid, cgrid2d *gradient) ;
void cgrid2d_fd_gradient_cyl(const cgrid2d *grid, cgrid2d *gradient_z, cgrid2d *gradient_r) ;
void cgrid2d_fd_laplace_cyl(const cgrid2d *grid, cgrid2d *laplace) ;
inline double complex cgrid2d_value_cyl(const cgrid2d *grid, double z, double r) ;
double complex cgrid2d_integral_of_conjugate_product_cyl(const cgrid2d *grida, const cgrid2d *gridb) ;
void cgrid2d_extrapolate_cyl(cgrid2d *dest, cgrid2d *src) ;
void cgrid2d_fftw_alloc(cgrid2d *grid) ;
void cgrid2d_fftw_free(cgrid2d *grid) ;
void cgrid2d_fftw(cgrid2d *grid) ;
void cgrid2d_fftw_inv(cgrid2d *grid) ;
cgrid3d *cgrid3d_alloc(long nx, long ny, long nz, double step, double complex (*value_outside)(const cgrid3d *grid, long i, long j, long k), void *outside_params_ptr) ;
void cgrid3d_set_origin( cgrid3d *grid , double x0, double y0, double z0);
void cgrid3d_shift_origin( cgrid3d *grid , double x0, double y0, double z0);
void cgrid3d_set_momentum( cgrid3d *grid , double kx0, double ky0, double kz0);
void cgrid3d_free(cgrid3d *grid) ;
void cgrid3d_write(cgrid3d *grid, FILE *out) ;
void grid3d_read_peek(FILE *fp, long *nx, long *ny, long *nz, double *step) ;
void cgrid3d_read(cgrid3d *grid, FILE *in) ;
void cgrid3d_copy(cgrid3d *copy, const cgrid3d *grid) ;
void cgrid3d_conjugate(cgrid3d *conjugate, const cgrid3d *grid) ;
void cgrid3d_shift(cgrid3d *shifted, const cgrid3d *grid, double x, double y, double z) ;
void cgrid3d_zero(cgrid3d *grid) ; 
void cgrid3d_constant(cgrid3d *grid, double complex c) ;
void cgrid3d_product_func(cgrid3d *grid, double complex (*func)(void *arg, double x, double y, double z), void *farg) ;
void cgrid3d_map(cgrid3d *grid, double complex (*func)(void *arg, double x, double y, double z), void *farg) ;
void cgrid3d_smooth_map(cgrid3d *grid, double complex (*func)(void *arg, double x, double y, double z), void *farg, int ns) ;
void cgrid3d_adaptive_map(cgrid3d *grid, double complex (*func)(void *arg, double x, double y, double z), void *farg, int min_ns, int max_ns, double tol) ;
void cgrid3d_sum(cgrid3d *gridc, const cgrid3d *grida, const cgrid3d *gridb) ;
void cgrid3d_difference(cgrid3d *gridc, const cgrid3d *grida, const cgrid3d *gridb) ;
void cgrid3d_product(cgrid3d *gridc, const cgrid3d *grida, const cgrid3d *gridb) ;
void cgrid3d_power(cgrid3d *gridb, const cgrid3d *grida, double exponent) ;
void cgrid3d_abs_power(cgrid3d *gridb, const cgrid3d *grida, double exponent) ;
void cgrid3d_division(cgrid3d *gridc, const cgrid3d *grida, const cgrid3d *gridb) ;
void cgrid3d_conjugate_product(cgrid3d *gridc, const cgrid3d *grida, const cgrid3d *gridb) ;
void cgrid3d_add(cgrid3d *grid, double complex c) ;
void cgrid3d_multiply(cgrid3d *grid, double complex c) ;
void cgrid3d_add_and_multiply(cgrid3d *grid, double complex ca, double complex cm) ;
void cgrid3d_multiply_and_add(cgrid3d *grid, double complex cm, double complex ca) ;
void cgrid3d_add_scaled(cgrid3d *gridc, double complex d, const cgrid3d *grida) ;
void cgrid3d_add_scaled_product(cgrid3d *gridc, double complex d, const cgrid3d *grida, const cgrid3d *gridb) ;
void cgrid3d_operate_one(cgrid3d *gridc, const cgrid3d *grida, double complex (*operator)(double complex a)) ;
void cgrid3d_operate_two(cgrid3d *gridc, const cgrid3d *grida, const cgrid3d *gridb, double complex (*operator)(double complex a, double complex b)) ;
void cgrid3d_transform_one(cgrid3d *grid, void (*operator)(double complex *a)) ;
void cgrid3d_transform_two(cgrid3d *grida, cgrid3d *gridb, void (*operator)(double complex *a, double complex *b)) ;
double complex cgrid3d_integral(const cgrid3d *grid) ;
double complex cgrid3d_integral_region(const cgrid3d *grid, double xl, double xu, double yl, double yu, double zl, double zu) ;
double cgrid3d_integral_of_square(const cgrid3d *grid) ;
double complex cgrid3d_integral_of_conjugate_product(const cgrid3d *grida, const cgrid3d *gridb) ;
double complex cgrid3d_grid_expectation_value(const cgrid3d *grida, const cgrid3d *gridb) ;
double complex cgrid3d_grid_expectation_value_func(void *arg, double complex (*func)(void *arg, double complex val, double x, double y, double z), const cgrid3d *grida) ;
double complex cgrid3d_weighted_integral(const cgrid3d *grid, double complex (*weight)(void *farg, double x, double y, double z), void *farg) ;
double cgrid3d_weighted_integral_of_square(const cgrid3d *grid, double (*weight)(void *farg, double x, double y, double z), void *farg) ;
void cgrid3d_fd_gradient_x(const cgrid3d *grid, cgrid3d *gradient) ;
void cgrid3d_fd_gradient_y(const cgrid3d *grid, cgrid3d *gradient) ;
void cgrid3d_fd_gradient_z(const cgrid3d *grid, cgrid3d *gradient) ;
void cgrid3d_fd_gradient(const cgrid3d *grid, cgrid3d *gradient_x, cgrid3d *gradient_y, cgrid3d *gradient_z) ;
void cgrid3d_fd_laplace(const cgrid3d *grid, cgrid3d *laplace) ;
void cgrid3d_fd_gradient_dot_gradient(const cgrid3d *grid, cgrid3d *grad_dot_grad) ;
void cgrid3d_print(const cgrid3d *grid, FILE *out) ;
void cgrid3d_fft(cgrid3d *grid) ;
void cgrid3d_inverse_fft(cgrid3d *grid) ;
void cgrid3d_scaled_inverse_fft(cgrid3d *grid, double complex c) ;
void cgrid3d_inverse_fft_norm(cgrid3d *grid) ;
void cgrid3d_fft_convolute(cgrid3d *gridc, const cgrid3d *grida, const cgrid3d *gridb) ;
void cgrid3d_fft_gradient_x(const cgrid3d *grid, cgrid3d *gradient_x) ;
void cgrid3d_fft_gradient_y(const cgrid3d *grid, cgrid3d *gradient_y) ;
void cgrid3d_fft_gradient_z(const cgrid3d *grid, cgrid3d *gradient_z) ;
void cgrid3d_fft_gradient(const cgrid3d *grid, cgrid3d *gradient_x, cgrid3d *gradient_y, cgrid3d *gradient_z) ;
void cgrid3d_fft_laplace(const cgrid3d *grid, cgrid3d *laplace)  ;
double cgrid3d_fft_laplace_expectation_value(const cgrid3d *grid, cgrid3d *laplace)  ;
double complex cgrid3d_value_outside_constantdirichlet(const cgrid3d *grid, long i, long j, long k) ;
double complex cgrid3d_value_outside_neumann(const cgrid3d *grid, long i, long j, long k) ;
double complex cgrid3d_value_outside_periodic(const cgrid3d *grid, long i, long j, long k) ;
double complex cgrid3d_value_outside_vortex_x(const cgrid3d *grid, long i, long j, long k) ;
double complex cgrid3d_value_outside_vortex_y(const cgrid3d *grid, long i, long j, long k) ;
double complex cgrid3d_value_outside_vortex_z(const cgrid3d *grid, long i, long j, long k) ;
inline double complex cgrid3d_value_at_index(const cgrid3d *grid, long i, long j, long k) ;
inline double complex cgrid3d_value(const cgrid3d *grid, double x, double y, double z) ;
void cgrid3d_extrapolate(cgrid3d *dest, cgrid3d *src) ;
void cgrid3d_rotate_z(cgrid3d *out, cgrid3d *in, double th) ;
void cgrid3d_zero_re(cgrid3d *grid) ;
void cgrid3d_zero_im(cgrid3d *grid) ;
void cgrid3d_phase(rgrid3d *dst, cgrid3d *src) ;
void cgrid3d_random(cgrid3d *grid, double scale) ;
inline double complex cgrid3d_value_at_index_cyl(const cgrid3d *grid, long i, long j, long k) ;
void cgrid3d_product_func_cyl(cgrid3d *grid, double complex (*func)(void *arg, double r, double phi, double z), void *farg) ;
void cgrid3d_map_cyl(cgrid3d *grid, double complex (*func)(void *arg, double r, double phi, double z), void *farg) ;
double complex cgrid3d_integral_cyl(const cgrid3d *grid) ;
double complex cgrid3d_integral_region_cyl(const cgrid3d *grid, double rl, double ru, double phil, double phiu, double zl, double zu) ;
double cgrid3d_integral_of_square_cyl(const cgrid3d *grid) ;
double complex cgrid3d_integral_of_conjugate_product_cyl(const cgrid3d *grida, const cgrid3d *gridb) ;
double complex cgrid3d_grid_expectation_value_cyl(const cgrid3d *grida, const cgrid3d *gridb) ;
double complex cgrid3d_grid_expectation_value_func_cyl(void *arg, double complex (*func)(void *arg, double val, double r, double phi, double z), const cgrid3d *grida) ;
double complex cgrid3d_weighted_integral_cyl(const cgrid3d *grid, double complex (*weight)(void *farg, double r, double phi, double z), void *farg) ;
double cgrid3d_weighted_integral_of_square_cyl(const cgrid3d *grid, double complex (*weight)(void *farg, double r, double phi, double z), void *farg) ;
void cgrid3d_fd_gradient_cyl_r(const cgrid3d *grid, cgrid3d *gradient) ;
void cgrid3d_fd_gradient_cyl_phi(const cgrid3d *grid, cgrid3d *gradient) ;
void cgrid3d_fd_gradient_cyl_z(const cgrid3d *grid, cgrid3d *gradient) ;
void cgrid3d_fd_gradient_cyl(const cgrid3d *grid, cgrid3d *gradient_r, cgrid3d *gradient_phi, cgrid3d *gradient_z) ;
void cgrid3d_fd_laplace_cyl(const cgrid3d *grid, cgrid3d *laplace) ;
inline double complex cgrid3d_value_cyl(const cgrid3d *grid, double r, double phi, double z) ;
void cgrid3d_extrapolate_cyl(cgrid3d *dest, cgrid3d *src) ;
void cgrid3d_map_cyl_on_cart(cgrid3d *cart, cgrid3d *cyl) ;
void cgrid3d_map_cart_on_cyl(cgrid3d *cyl, cgrid3d *cart) ;
void cgrid3d_add_cyl_on_cart(cgrid3d *cart, cgrid3d *cyl) ;
void cgrid3d_add_cart_on_cyl(cgrid3d *cyl, cgrid3d *cart) ;
void cgrid3d_fftw_alloc(cgrid3d *grid) ;
void cgrid3d_fftw_free(cgrid3d *grid) ;
void cgrid3d_fftw(cgrid3d *grid) ;
void cgrid3d_fftw_inv(cgrid3d *grid) ;
void grid_timer_start(grid_timer *timer) ;
double grid_timer_wall_clock_time(grid_timer *timer) ;
double grid_timer_cpu_time(grid_timer *timer) ;
double grid1d_itp_linear(wf1d **gwf, int states, int virtuals, const cgrid1d *potential, double tau, double threshold, int max_iterations, double *rtau, int *riterations) ;
double grid1d_itp_nonlinear(wf1d **gwf, int states, int virtuals, void (*calculate_potentials)(cgrid1d **potential, void *arg, wf1d **gwf, int states), void *arg, double tau, double threshold, int max_iterations, double *rtau, int *riterations) ;
wf1d *grid1d_wf_alloc(long nx, double step, double mass, int boundary, int propagator) ;
void grid1d_wf_free(wf1d *gwf) ;
void grid1d_wf_absorb(cgrid1d *potential, rgrid1d *density, double rho0, double (*region)(void *, double), rgrid1d *workspace) ;
void grid1d_wf_probability_flux(const wf1d *gwf, rgrid1d *flux_x) ;
void grid1d_wf_momentum(const wf1d *gwf, cgrid1d *momentum_x, cgrid1d *workspace) ;
double grid1d_wf_energy(const wf1d *gwf, const cgrid1d *potential, cgrid1d *workspace) ;
double grid1d_wf_energy_cn(const wf1d *gwfa, const wf1d *gwfb, const cgrid1d *potential, cgrid1d *workspace) ;
double grid1d_wf_energy_fft(const wf1d *gwf, const cgrid1d *potential, cgrid1d *workspace) ;
double grid1d_wf_kinetic_energy_fft(const wf1d *gwf, cgrid1d *workspace) ;
double grid1d_wf_potential_energy(const wf1d *gwf, const cgrid1d *potential) ;
double grid1d_wf_energy_and_error(const wf1d *gwf, const cgrid1d *potential, cgrid1d *workspace, double *error) ; 
void grid1d_wf_propagate(wf1d *gwf, const cgrid1d *potential, const cgrid1d *sq_grad_pot, double complex time, cgrid1d *workspace) ;  
void grid1d_wf_propagate_kinetic_fft(wf1d *gwf, double complex time) ;
void grid1d_wf_propagate_kinetic_cn(wf1d *gwf, double complex time, cgrid1d *workspace) ;
void grid1d_wf_propagate_potential(wf1d *gwf, const cgrid1d *potential, double complex time) ;
void grid1d_wf_project_out(wf1d *gwfa, const wf1d *gwfb) ;
void grid1d_wf_diagonalize(wf1d **gwf, int states) ;
void grid1d_wf_linear_transform(wf1d **gwf, double complex *transform, int states) ;
void grid1d_wf_square_of_potential_gradient(cgrid1d *sq_grad_pot, const cgrid1d *potential) ;
void grid1d_wf_propagate_kinetic_cn_dbc(wf1d *gwf, double complex time, cgrid1d *workspace) ;
void grid1d_wf_propagate_kinetic_x_cn_dbc(wf1d *gwf, double complex time, cgrid1d *workspace) ;
void grid1d_wf_propagate_kinetic_cn_nbc(wf1d *gwf, double complex time, cgrid1d *workspace) ;
void grid1d_wf_propagate_kinetic_x_cn_nbc(wf1d *gwf, double complex time, cgrid1d *workspace) ;
void grid1d_wf_propagate_kinetic_cn_pbc(wf1d *gwf, double complex time, cgrid1d *workspace) ;
void grid1d_wf_propagate_kinetic_x_cn_pbc(wf1d *gwf, double complex time, cgrid1d *workspace) ;
inline void grid1d_wf_density(const wf1d *gwf, rgrid1d *density) ;
inline void grid1d_wf_zero(wf1d *gwf) ; 
inline void grid1d_wf_constant(wf1d *gwf, double complex c) ; 
inline void grid1d_wf_map(wf1d *gwf, double complex (*func)(void *arg, double x), void *farg) ; 
inline double grid1d_wf_norm(const wf1d *gwf) ; 
inline double grid1d_wf_normalize(wf1d *gwf) ; 
inline double complex grid1d_wf_overlap(const wf1d *gwfa, const wf1d *gwfb) ; 
inline void grid1d_wf_print(const wf1d *gwf, FILE *out) ; 
void rgrid2d_fft_cylindrical_cleanup(rgrid2d *grid, long hankel_pad) ;
void rgrid2d_fft_cylindrical_alloc(rgrid2d *grid) ;
void rgrid2d_fft_cylindrical_free(rgrid2d *grid) ;
void rgrid2d_fft_cylindrical(rgrid2d *grid) ;
void rgrid2d_inverse_fft_cylindrical(rgrid2d *grid) ;
void rgrid2d_fft_cylindrical_convolute(rgrid2d *dest, rgrid2d *grid1, rgrid2d *grid2) ;
double grid2d_itp_linear(wf2d **gwf, int states, int virtuals, const cgrid2d *potential, double tau, double threshold, int max_iterations, double *rtau, int *riterations) ;
double grid2d_itp_nonlinear(wf2d **gwf, int states, int virtuals, void (*calculate_potentials)(cgrid2d **potential, void *arg, wf2d **gwf, int states), void *arg, double tau, double threshold, int max_iterations, double *rtau, int *riterations) ;
wf2d *grid2d_wf_alloc(long nx, long ny, double step, double mass, int boundary, int propagator) ;
void grid2d_wf_free(wf2d *gwf) ;
void grid2d_wf_absorb(cgrid2d *potential, rgrid2d *density, double rho0, double (*region)(void *, double, double), rgrid2d *workspace) ;
void grid2d_wf_probability_flux_x(const wf2d *gwf, rgrid2d *flux_x) ;
void grid2d_wf_probability_flux_y(const wf2d *gwf, rgrid2d *flux_y) ;
void grid2d_wf_probability_flux(const wf2d *gwf, rgrid2d *flux_x, rgrid2d *flux_y) ;
void grid2d_wf_momentum_x(const wf2d *gwf, cgrid2d *momentum_x, cgrid2d *workspace) ;
void grid2d_wf_momentum_y(const wf2d *gwf, cgrid2d *momentum_y, cgrid2d *workspace) ;
void grid2d_wf_momentum(const wf2d *gwf, cgrid2d *momentum_x, cgrid2d *momentum_y, cgrid2d *workspace) ;
double grid2d_wf_energy(const wf2d *gwf, const cgrid2d *potential, cgrid2d *workspace) ;
double grid2d_wf_energy_cn(const wf2d *gwfa, const wf2d *gwfb, const cgrid2d *potential, cgrid2d *workspace) ;
double grid2d_wf_energy_fft(const wf2d *gwf, const cgrid2d *potential, cgrid2d *workspace) ;
double grid2d_wf_kinetic_energy_fft(const wf2d *gwf, cgrid2d *workspace) ;
double grid2d_wf_potential_energy(const wf2d *gwf, const cgrid2d *potential) ;
double grid2d_wf_energy_and_error(const wf2d *gwf, const cgrid2d *potential, cgrid2d *workspace, double *error) ; 
void grid2d_wf_propagate(wf2d *gwf, const cgrid2d *potential, const cgrid2d *sq_grad_pot, double complex time, cgrid2d *workspace) ;  
void grid2d_wf_propagate_kinetic_fft(wf2d *gwf, double complex time) ;
void grid2d_wf_propagate_kinetic_cn(wf2d *gwf, double complex time, cgrid2d *workspace) ;
void grid2d_wf_propagate_potential(wf2d *gwf, const cgrid2d *potential, double complex time) ;
void grid2d_wf_project_out(wf2d *gwfa, const wf2d *gwfb) ;
void grid2d_wf_diagonalize(wf2d **gwf, int states) ;
void grid2d_wf_linear_transform(wf2d **gwf, double complex *transform, int states) ;
void grid2d_wf_square_of_potential_gradient(cgrid2d *sq_grad_pot, const cgrid2d *potential, cgrid2d *workspace) ;
void grid2d_wf_propagate_kinetic_cn_dbc(wf2d *gwf, double complex time, cgrid2d *workspace) ;
void grid2d_wf_propagate_kinetic_x_cn_dbc(wf2d *gwf, double complex time, cgrid2d *workspace) ;
void grid2d_wf_propagate_kinetic_y_cn_dbc(wf2d *gwf, double complex time, cgrid2d *workspace) ;
void grid2d_wf_propagate_kinetic_cn_nbc(wf2d *gwf, double complex time, cgrid2d *workspace) ;
void grid2d_wf_propagate_kinetic_x_cn_nbc(wf2d *gwf, double complex time, cgrid2d *workspace) ;
void grid2d_wf_propagate_kinetic_y_cn_nbc(wf2d *gwf, double complex time, cgrid2d *workspace) ;
void grid2d_wf_propagate_kinetic_cn_pbc(wf2d *gwf, double complex time, cgrid2d *workspace) ;
void grid2d_wf_propagate_kinetic_x_cn_pbc(wf2d *gwf, double complex time, cgrid2d *workspace) ;
void grid2d_wf_propagate_kinetic_y_cn_pbc(wf2d *gwf, double complex time, cgrid2d *workspace) ;
inline void grid2d_wf_density(const wf2d *gwf, rgrid2d *density) ;
inline void grid2d_wf_zero(wf2d *gwf) ; 
inline void grid2d_wf_constant(wf2d *gwf, double complex c) ; 
inline void grid2d_wf_map(wf2d *gwf, double complex (*func)(void *arg, double x, double y), void *farg) ; 
inline double grid2d_wf_norm(const wf2d *gwf) ; 
inline double grid2d_wf_normalize(wf2d *gwf) ; 
inline double complex grid2d_wf_overlap(const wf2d *gwfa, const wf2d *gwfb) ; 
inline void grid2d_wf_print(const wf2d *gwf, FILE *out) ; 
void grid2d_wf_propagate_kinetic_cn_cyl(wf2d *gwf, double complex time, cgrid2d *workspace) ;
void grid2d_wf_propagate_kinetic_cn_cyl_z(wf2d *gwf, double complex time, cgrid2d *workspace) ;
void grid2d_wf_propagate_kinetic_cn_cyl_r(wf2d *gwf, double complex time, cgrid2d *workspace) ;
inline void grid2d_wf_map_cyl(wf2d *gwf, double complex (*func)(void *arg, double z, double r), void *farg) ; 
double grid2d_wf_norm_cyl(const wf2d *gwf) ; 
inline double grid2d_wf_normalize_cyl(wf2d *gwf) ; 
double grid2d_wf_energy_cyl(const wf2d *gwf, const cgrid2d *potential, cgrid2d *cworkspace) ;
void grid2d_wf_absorb_cyl(cgrid2d *potential, rgrid2d *density, double rho0, double (*region)(void *, double, double), rgrid2d *workspace) ;
double grid3d_itp_linear(wf3d **gwf, int states, int virtuals, const cgrid3d *potential, double tau, double threshold, int max_iterations, double *rtau, int *riterations) ;
double grid3d_itp_nonlinear(wf3d **gwf, int states, int virtuals, void (*calculate_potentials)(cgrid3d **potential, void *arg, wf3d **gwf, int states), void *arg, double tau, double threshold, int max_iterations, double *rtau, int *riterations) ;
wf3d *grid3d_wf_alloc(long nx, long ny, long nz, double step, double mass, int boundary, int propagator) ;
void grid3d_wf_free(wf3d *gwf) ;
void grid3d_wf_absorb(cgrid3d *potential, rgrid3d *density, double rho0, double (*region)(void *, double, double, double), rgrid3d *workspace, double complex c) ;
void grid3d_damp_wf(wf3d *wf , double rho0 , double damping, double complex (*region)(void *, double, double, double) , cgrid3d *cworkspace, void *farg );
void grid3d_wf_probability_flux_x(const wf3d *gwf, rgrid3d *flux_x) ;
void grid3d_wf_probability_flux_y(const wf3d *gwf, rgrid3d *flux_y) ;
void grid3d_wf_probability_flux_z(const wf3d *gwf, rgrid3d *flux_z) ;
void grid3d_wf_probability_flux(const wf3d *gwf, rgrid3d *flux_x, rgrid3d *flux_y, rgrid3d *flux_z) ;
void grid3d_wf_momentum_x(const wf3d *gwf, cgrid3d *momentum_x, cgrid3d *workspace) ;
void grid3d_wf_momentum_y(const wf3d *gwf, cgrid3d *momentum_y, cgrid3d *workspace) ;
void grid3d_wf_momentum_z(const wf3d *gwf, cgrid3d *momentum_z, cgrid3d *workspace) ;
void grid3d_wf_momentum(const wf3d *gwf, cgrid3d *momentum_x, cgrid3d *momentum_y, cgrid3d *momentum_z, cgrid3d *workspace) ;
double grid3d_wf_energy(const wf3d *gwf, const cgrid3d *potential, cgrid3d *workspace) ;
double grid3d_wf_energy_cn(const wf3d *gwfa, const wf3d *gwfb, const cgrid3d *potential, cgrid3d *workspace) ;
double grid3d_wf_energy_fft(const wf3d *gwf, const cgrid3d *potential, cgrid3d *workspace) ;
double grid3d_wf_kinetic_energy_fft(const wf3d *gwf, cgrid3d *workspace) ;
double grid3d_wf_potential_energy(const wf3d *gwf, const cgrid3d *potential) ;
double grid3d_wf_energy_and_error(const wf3d *gwf, const cgrid3d *potential, cgrid3d *workspace, double *error) ; 
void grid3d_wf_propagate(wf3d *gwf, const cgrid3d *potential, const cgrid3d *sq_grad_pot, double complex time, cgrid3d *workspace) ;  
void grid3d_wf_propagate_kinetic_fft(wf3d *gwf, double complex time) ;
void grid3d_wf_propagate_kinetic_cn(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_potential(wf3d *gwf, const cgrid3d *potential, double complex time) ;
void grid3d_wf_project_out(wf3d *gwfa, const wf3d *gwfb) ;
void grid3d_wf_diagonalize(wf3d **gwf, int states) ;
void grid3d_wf_linear_transform(wf3d **gwf, double complex *transform, int states) ;
void grid3d_wf_square_of_potential_gradient(cgrid3d *sq_grad_pot, const cgrid3d *potential, cgrid3d *workspace, cgrid3d *workspace2) ;
void grid3d_wf_propagate_kinetic_cn_dbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_x_cn_dbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_y_cn_dbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_z_cn_dbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_cn_nbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_x_cn_nbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_y_cn_nbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_z_cn_nbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_cn_nbc_rot(wf3d *gwf, double complex time, double omega, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_x_cn_nbc_rot(wf3d *gwf, double complex time, double omega, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_y_cn_nbc_rot(wf3d *gwf, double complex time, double omega, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_cn_pbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_x_cn_pbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_y_cn_pbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_z_cn_pbc(wf3d *gwf, double complex time, cgrid3d *workspace) ;
inline void grid3d_wf_density(const wf3d *gwf, rgrid3d *density) ;
inline void grid3d_wf_zero(wf3d *gwf) ; 
inline void grid3d_wf_constant(wf3d *gwf, double complex c) ; 
inline void grid3d_wf_map(wf3d *gwf, double complex (*func)(void *arg, double x, double y, double z), void *farg) ; 
inline double grid3d_wf_norm(const wf3d *gwf) ; 
inline double grid3d_wf_normalize(wf3d *gwf) ; 
inline double complex grid3d_wf_overlap(const wf3d *gwfa, const wf3d *gwfb) ; 
inline void grid3d_wf_print(const wf3d *gwf, FILE *out) ; 
double grid3d_wf_energy_cyl(const wf3d *gwf, const cgrid3d *potential, cgrid3d *workspace) ;
double grid3d_wf_energy_cn_cyl(const wf3d *gwfa, const wf3d *gwfb, const cgrid3d *potential, cgrid3d *workspace) ;
double grid3d_wf_potential_energy_cyl(const wf3d *gwf, const cgrid3d *potential) ;
void grid3d_wf_propagate_kinetic_cn_cyl(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_cn_cyl_r(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_cn_cyl_phi(wf3d *gwf, double complex time, cgrid3d *workspace) ;
void grid3d_wf_propagate_kinetic_cn_cyl_z(wf3d *gwf, double complex time, cgrid3d *workspace) ;
inline void grid3d_wf_map_cyl(wf3d *gwf, double complex (*func)(void *arg, double z, double r, double phi), void *farg) ; 
inline double grid3d_wf_norm_cyl(const wf3d *gwf) ; 
inline double grid3d_wf_normalize_cyl(wf3d *gwf) ; 
inline double complex grid3d_wf_overlap_cyl(const wf3d *gwfa, const wf3d *gwfb) ; 
void grid3d_wf_absorb_cyl(cgrid3d *potential, rgrid3d *density, double rho0, double (*region)(void *, double, double, double), rgrid3d *workspace, double complex c) ;
int grid_generalized_hermitian_eigenvalue_problem(double *eigenvalue, double complex *hamiltonian, double complex *overlap, int states) ;
int grid_hermitian_eigenvalue_problem(double *eigenvalue, double complex *overlap, int states) ;
void grid_solve_tridiagonal_system(long n, double complex *a, double complex *b, double complex *c, double complex *v, double complex *x) ;
void grid_solve_tridiagonal_system_cyclic(long n, double complex *a, double complex *b, double complex *c, double complex *v, double complex alpha, double complex beta, double complex *x, double complex *bb) ;
void grid_cholesky_decomposition(double complex *a, long n, int w) ;
void grid_cholesky_substitute(double complex *ld, double complex *b, long n, int w) ;
double grid_polynomial_interpolate(double *xa, double *ya, long n, double x, double *dy) ;
 void grid_spline_ypp( double *x, double *y, long n, double yp1, double ypn , double *y2 );
double *grid_spline_ypp_new( double *x, double *y, long n, double yp1, double ypn);
double grid_spline_interpolate(double *xa, double *ya, double *y2a, long n, double x);
rgrid1d *rgrid1d_alloc(long nx, double step, double (*value_outside)(const rgrid1d *grid, long i), void *outside_params_ptr) ;
void rgrid1d_free(rgrid1d *grid) ;
void rgrid1d_write(rgrid1d *grid, FILE *out) ;
void rgrid1d_read(rgrid1d *grid, FILE *in) ;
void rgrid1d_copy(rgrid1d *copy, const rgrid1d *grid) ;
void rgrid1d_shift(rgrid1d *shifted, const rgrid1d *grid, double x) ;
void rgrid1d_zero(rgrid1d *grid) ; 
void rgrid1d_constant(rgrid1d *grid, double c) ;
void rgrid1d_product_func(rgrid1d *grid, double (*func)(void *arg, double x), void *farg) ;
void rgrid1d_map(rgrid1d *grid, double (*func)(void *arg, double x), void *farg) ;
void rgrid1d_smooth_map(rgrid1d *grid, double (*func)(void *arg, double x), void *farg, int ns) ;
void rgrid1d_adaptive_map(rgrid1d *grid, double (*func)(void *arg, double x), void *farg, int min_ns, int max_ns, double tol) ;
void rgrid1d_sum(rgrid1d *gridc, const rgrid1d *grida, const rgrid1d *gridb) ;
void rgrid1d_difference(rgrid1d *gridc, const rgrid1d *grida, const rgrid1d *gridb) ;
void rgrid1d_product(rgrid1d *gridc, const rgrid1d *grida, const rgrid1d *gridb) ;
void rgrid1d_power(rgrid1d *gridb, const rgrid1d *grida, double exponent) ;
void rgrid1d_abs_power(rgrid1d *gridb, const rgrid1d *grida, double exponent) ;
void rgrid1d_division(rgrid1d *gridc, const rgrid1d *grida, const rgrid1d *gridb) ;
void rgrid1d_conjugate_product(rgrid1d *gridc, const rgrid1d *grida, const rgrid1d *gridb) ;
void rgrid1d_add(rgrid1d *grid, double c) ;
void rgrid1d_multiply(rgrid1d *grid, double c) ;
void rgrid1d_add_and_multiply(rgrid1d *grid, double ca, double cm) ;
void rgrid1d_multiply_and_add(rgrid1d *grid, double cm, double ca) ;
void rgrid1d_add_scaled(rgrid1d *gridc, double d, const rgrid1d *grida) ;
void rgrid1d_add_scaled_product(rgrid1d *gridc, double d, const rgrid1d *grida, const rgrid1d *gridb) ;
void rgrid1d_operate_one(rgrid1d *gridc, const rgrid1d *grida, double (*operator)(double a)) ;
void rgrid1d_operate_two(rgrid1d *gridc, const rgrid1d *grida, const rgrid1d *gridb, double (*operator)(double a, double b)) ;
void rgrid1d_transform_one(rgrid1d *grid, void (*operator)(double *a)) ;
void rgrid1d_transform_two(rgrid1d *grida, rgrid1d *gridb, void (*operator)(double *a, double *b)) ;
double rgrid1d_integral(const rgrid1d *grid) ;
double rgrid1d_integral_region(const rgrid1d *grid, double xl, double xu) ;
double rgrid1d_integral_of_square(const rgrid1d *grid) ;
double rgrid1d_integral_of_product(const rgrid1d *grida, const rgrid1d *gridb) ;
double rgrid1d_grid_expectation_value(const rgrid1d *grida, const rgrid1d *gridb) ;
double rgrid1d_grid_expectation_value_func(void *arg, double (*func)(void *arg, double val, double x), const rgrid1d *grida) ;
double rgrid1d_weighted_integral(const rgrid1d *grid, double (*weight)(void *farg, double x), void *farg) ;
double rgrid1d_weighted_integral_of_square(const rgrid1d *grid, double (*weight)(void *farg, double x), void *farg) ;
void rgrid1d_fd_gradient(const rgrid1d *grid, rgrid1d *gradient) ;
void rgrid1d_fd_gradient_x(const rgrid1d *grid, rgrid1d *gradient) ;
void rgrid1d_fd_laplace(const rgrid1d *grid, rgrid1d *laplace) ;
void rgrid1d_fd_gradient_dot_gradient(const rgrid1d *grid, rgrid1d *grad_dot_grad);
void rgrid1d_print(const rgrid1d *grid, FILE *out) ;
void rgrid1d_fft(rgrid1d *grid) ;
void rgrid1d_fourier_transform(rgrid1d *grid) ;
void rgrid1d_inverse_fft(rgrid1d *grid) ;
void rgrid1d_scaled_inverse_fft(rgrid1d *grid, double c) ;
void rgrid1d_inverse_fft_norm(rgrid1d *grid) ;
void rgrid1d_inverse_fourier_transform(rgrid1d *grid) ;
void rgrid1d_fft_convolute(rgrid1d *gridc, const rgrid1d *grida, const rgrid1d *gridb) ;
double rgrid1d_value_outside_constantdirichlet(const rgrid1d *grid, long i) ;
double rgrid1d_value_outside_neumann(const rgrid1d *grid, long i) ;
double rgrid1d_value_outside_periodic(const rgrid1d *grid, long i) ;
inline double rgrid1d_value_at_index(const rgrid1d *grid, long i) ;
inline double rgrid1d_value(const rgrid1d *grid, double x) ;
void grid1d_real_to_complex_re(cgrid1d *dest, rgrid1d *source) ;
void grid1d_real_to_complex_im(cgrid1d *dest, rgrid1d *source) ;
void grid1d_product_complex_with_real(cgrid1d *dest, rgrid1d *source) ;
void grid1d_add_real_to_complex_re(cgrid1d *dest, rgrid1d *source) ;
void grid1d_add_real_to_complex_im(cgrid1d *dest, rgrid1d *source) ;
void grid1d_complex_im_to_real(rgrid1d *dest, cgrid1d *source) ;
void grid1d_complex_re_to_real(rgrid1d *dest, cgrid1d *source) ;
void rgrid1d_extrapolate(rgrid1d *dest, rgrid1d *src) ;
double rgrid1d_max(rgrid1d *grid);
double rgrid1d_min(rgrid1d *grid);
void rgrid1d_fftw_alloc(rgrid1d *grid) ;
void rgrid1d_fftw_free(rgrid1d *grid) ;
void rgrid1d_fftw(rgrid1d *grid) ;
void rgrid1d_fftw_inv(rgrid1d *grid) ;
rgrid2d *rgrid2d_alloc(long nx, long ny, double step, double (*value_outside)(const rgrid2d *grid, long i, long j), void *outside_params_ptr) ;
void rgrid2d_free(rgrid2d *grid) ;
void rgrid2d_write(rgrid2d *grid, FILE *out) ;
void rgrid2d_read(rgrid2d *grid, FILE *in) ;
void rgrid2d_copy(rgrid2d *copy, const rgrid2d *grid) ;
void rgrid2d_shift(rgrid2d *shifted, const rgrid2d *grid, double x, double y) ;
void rgrid2d_zero(rgrid2d *grid) ; 
void rgrid2d_constant(rgrid2d *grid, double c) ;
void rgrid2d_product_func(rgrid2d *grid, double (*func)(void *arg, double x, double y), void *farg) ;
void rgrid2d_map(rgrid2d *grid, double (*func)(void *arg, double x, double y), void *farg) ;
void rgrid2d_smooth_map(rgrid2d *grid, double (*func)(void *arg, double x, double y), void *farg, int ns) ;
void rgrid2d_adaptive_map(rgrid2d *grid, double (*func)(void *arg, double x, double y), void *farg, int min_ns, int max_ns, double tol) ;
void rgrid2d_sum(rgrid2d *gridc, const rgrid2d *grida, const rgrid2d *gridb) ;
void rgrid2d_difference(rgrid2d *gridc, const rgrid2d *grida, const rgrid2d *gridb) ;
void rgrid2d_product(rgrid2d *gridc, const rgrid2d *grida, const rgrid2d *gridb) ;
void rgrid2d_power(rgrid2d *gridb, const rgrid2d *grida, double exponent) ;
void rgrid2d_abs_power(rgrid2d *gridb, const rgrid2d *grida, double exponent) ;
void rgrid2d_division(rgrid2d *gridc, const rgrid2d *grida, const rgrid2d *gridb) ;
void rgrid2d_add(rgrid2d *grid, double c) ;
void rgrid2d_multiply(rgrid2d *grid, double c) ;
void rgrid2d_add_and_multiply(rgrid2d *grid, double ca, double cm) ;
void rgrid2d_multiply_and_add(rgrid2d *grid, double cm, double ca) ;
void rgrid2d_add_scaled(rgrid2d *gridc, double d, const rgrid2d *grida) ;
void rgrid2d_add_scaled_product(rgrid2d *gridc, double d, const rgrid2d *grida, const rgrid2d *gridb) ;
void rgrid2d_operate_one(rgrid2d *gridc, const rgrid2d *grida, double (*operator)(double a)) ;
void rgrid2d_operate_two(rgrid2d *gridc, const rgrid2d *grida, const rgrid2d *gridb, double (*operator)(double a, double b)) ;
void rgrid2d_transform_one(rgrid2d *grid, void (*operator)(double *a)) ;
void rgrid2d_transform_two(rgrid2d *grida, rgrid2d *gridb, void (*operator)(double *a, double *b)) ;
double rgrid2d_integral(const rgrid2d *grid) ;
double rgrid2d_integral_region(const rgrid2d *grid, double xl, double xu, double yl, double yu) ;
double rgrid2d_integral_of_square(const rgrid2d *grid) ;
double rgrid2d_integral_of_product(const rgrid2d *grida, const rgrid2d *gridb) ;
double rgrid2d_grid_expectation_value(const rgrid2d *grida, const rgrid2d *gridb) ;
double rgrid2d_grid_expectation_value_func(void *arg, double (*func)(void *arg, double val, double x, double y), const rgrid2d *grida) ;
double rgrid2d_weighted_integral(const rgrid2d *grid, double (*weight)(void *farg, double x, double y), void *farg) ;
double rgrid2d_weighted_integral_of_square(const rgrid2d *grid, double (*weight)(void *farg, double x, double y), void *farg) ;
void rgrid2d_fd_gradient_x(const rgrid2d *grid, rgrid2d *gradient) ;
void rgrid2d_fd_gradient_y(const rgrid2d *grid, rgrid2d *gradient) ;
void rgrid2d_fd_gradient(const rgrid2d *grid, rgrid2d *gradient_x, rgrid2d *gradient_y) ;
void rgrid2d_fd_laplace(const rgrid2d *grid, rgrid2d *laplace) ;
void rgrid2d_fd_gradient_dot_gradient(const rgrid2d *grid, rgrid2d *grad_dot_grad) ;
void rgrid2d_print(const rgrid2d *grid, FILE *out) ;
void rgrid2d_fft(rgrid2d *grid) ;
void rgrid2d_fourier_transform(rgrid2d *grid) ;
void rgrid2d_inverse_fft(rgrid2d *grid) ;
void rgrid2d_scaled_inverse_fft(rgrid2d *grid, double c) ;
void rgrid2d_inverse_fft_norm(rgrid2d *grid) ;
void rgrid2d_inverse_fourier_transform(rgrid2d *grid) ;
void rgrid2d_fft_convolute(rgrid2d *gridc, const rgrid2d *grida, const rgrid2d *gridb) ;
double rgrid2d_value_outside_constantdirichlet(const rgrid2d *grid, long i, long j) ;
double rgrid2d_value_outside_neumann(const rgrid2d *grid, long i, long j) ;
double rgrid2d_value_outside_periodic(const rgrid2d *grid, long i, long j) ;
inline double rgrid2d_value_at_index(const rgrid2d *grid, long i, long j) ;
inline double rgrid2d_value(const rgrid2d *grid, double x, double y) ;
void grid2d_real_to_complex_re(cgrid2d *dest, rgrid2d *source) ;
void grid2d_real_to_complex_im(cgrid2d *dest, rgrid2d *source) ;
void grid2d_add_real_to_complex_re(cgrid2d *dest, rgrid2d *source) ;
void grid2d_add_real_to_complex_im(cgrid2d *dest, rgrid2d *source) ;
void grid2d_product_complex_with_real(cgrid2d *dest, rgrid2d *source) ;
void grid2d_complex_im_to_real(rgrid2d *dest, cgrid2d *source) ;
void grid2d_complex_re_to_real(rgrid2d *dest, cgrid2d *source) ;
void rgrid2d_extrapolate(rgrid2d *dest, rgrid2d *src) ;
double rgrid2d_max(rgrid2d *grid);
double rgrid2d_min(rgrid2d *grid);
void rgrid2d_product_func_cyl(rgrid2d *grid, double (*func)(void *arg, double z, double r), void *farg) ;
void rgrid2d_map_cyl(rgrid2d *grid, double (*func)(void *arg, double z, double r), void *farg) ;
void rgrid2d_smooth_map_cyl(rgrid2d *grid, double (*func)(void *arg, double z, double r), void *farg, int ns) ;
void rgrid2d_adaptive_map_cyl(rgrid2d *grid, double (*func)(void *arg, double z, double r), void *farg, int min_ns, int max_ns, double tol) ;
double rgrid2d_integral_cyl(const rgrid2d *grid) ;
double rgrid2d_integral_region_cyl(const rgrid2d *grid, double zl, double zu, double rl, double ru) ;
double rgrid2d_integral_of_square_cyl(const rgrid2d *grid) ;
double rgrid2d_integral_of_product_cyl(const rgrid2d *grida, const rgrid2d *gridb) ;
double rgrid2d_grid_expectation_value_cyl(const rgrid2d *grida, const rgrid2d *gridb) ;
double rgrid2d_grid_expectation_value_func_cyl(void *arg, double (*func)(void *arg, double val, double z, double r), const rgrid2d *grida) ;
double rgrid2d_weighted_integral_cyl(const rgrid2d *grid, double (*weight)(void *farg, double z, double r), void *farg) ;
double rgrid2d_weighted_integral_of_square_cyl(const rgrid2d *grid, double (*weight)(void *farg, double z, double r), void *farg) ;
void rgrid2d_fd_gradient_cyl_z(const rgrid2d *grid, rgrid2d *gradient) ;
void rgrid2d_fd_gradient_cyl_r(const rgrid2d *grid, rgrid2d *gradient) ;
void rgrid2d_fd_gradient_cyl_r(const rgrid2d *grid, rgrid2d *gradient) ;
void rgrid2d_fd_gradient_cyl(const rgrid2d *grid, rgrid2d *gradient_z, rgrid2d *gradient_r) ;
void rgrid2d_fd_laplace_cyl(const rgrid2d *grid, rgrid2d *laplace) ;
inline double rgrid2d_value_cyl(const rgrid2d *grid, double z, double r) ;
void rgrid2d_extrapolate_cyl(rgrid2d *dest, rgrid2d *src) ;
void rgrid2d_fftw_alloc(rgrid2d *grid) ;
void rgrid2d_fftw_free(rgrid2d *grid) ;
void rgrid2d_fftw(rgrid2d *grid) ;
void rgrid2d_fftw_inv(rgrid2d *grid) ;
rgrid3d *rgrid3d_alloc(long nx, long ny, long nz, double step, double (*value_outside)(const rgrid3d *grid, long i, long j, long k), void *outside_params_ptr) ;
void rgrid3d_set_origin( rgrid3d *grid , double x0, double y0, double z0);
void rgrid3d_shift_origin( rgrid3d *grid , double x0, double y0, double z0);
void rgrid3d_set_momentum( rgrid3d *grid , double kx0, double ky0, double kz0);
void rgrid3d_free(rgrid3d *grid) ;
void rgrid3d_write(rgrid3d *grid, FILE *out) ;
void rgrid3d_read(rgrid3d *grid, FILE *in) ;
void rgrid3d_copy(rgrid3d *copy, const rgrid3d *grid) ;
void rgrid3d_shift(rgrid3d *shifted, const rgrid3d *grid, double x, double y, double z) ;
void rgrid3d_zero(rgrid3d *grid) ; 
void rgrid3d_constant(rgrid3d *grid, double c) ;
void rgrid3d_product_func(rgrid3d *grid, double (*func)(void *arg, double x, double y, double z), void *farg) ;
void rgrid3d_map(rgrid3d *grid, double (*func)(void *arg, double x, double y, double z), void *farg) ;
void rgrid3d_mapk(rgrid3d *grid, double (*func)(void *arg, double kx, double ky, double kz), void *farg) ;
void rgrid3d_smooth_map(rgrid3d *grid, double (*func)(void *arg, double x, double y, double z), void *farg, int ns) ;
void rgrid3d_adaptive_map(rgrid3d *grid, double (*func)(void *arg, double x, double y, double z), void *farg, int min_ns, int max_ns, double tol) ;
void rgrid3d_map_nonperiodic(rgrid3d *grid, double (*func)(void *arg, double x, double y, double z), void *farg) ;
void rgrid3d_smooth_map_nonperiodic(rgrid3d *grid, double (*func)(void *arg, double x, double y, double z), void *farg, int ns) ;
void rgrid3d_adaptive_map_nonperiodic(rgrid3d *grid, double (*func)(void *arg, double x, double y, double z), void *farg, int min_ns, int max_ns, double tol) ;
void rgrid3d_sum(rgrid3d *gridc, const rgrid3d *grida, const rgrid3d *gridb) ;
void rgrid3d_difference(rgrid3d *gridc, const rgrid3d *grida, const rgrid3d *gridb) ;
void rgrid3d_product(rgrid3d *gridc, const rgrid3d *grida, const rgrid3d *gridb) ;
void rgrid3d_power(rgrid3d *gridb, const rgrid3d *grida, double exponent) ;
void rgrid3d_abs_power(rgrid3d *gridb, const rgrid3d *grida, double exponent) ;
void rgrid3d_division(rgrid3d *gridc, const rgrid3d *grida, const rgrid3d *gridb) ;
void rgrid3d_add(rgrid3d *grid, double c) ;
void rgrid3d_multiply(rgrid3d *grid, double c) ;
void rgrid3d_add_and_multiply(rgrid3d *grid, double ca, double cm) ;
void rgrid3d_multiply_and_add(rgrid3d *grid, double cm, double ca) ;
void rgrid3d_add_scaled(rgrid3d *gridc, double d, const rgrid3d *grida) ;
void rgrid3d_add_scaled_product(rgrid3d *gridc, double d, const rgrid3d *grida, const rgrid3d *gridb) ;
void rgrid3d_operate_one(rgrid3d *gridc, const rgrid3d *grida, double (*operator)(double a)) ;
void rgrid3d_operate_two(rgrid3d *gridc, const rgrid3d *grida, const rgrid3d *gridb, double (*operator)(double, double)) ;
void rgrid3d_transform_one(rgrid3d *grid, void (*operator)(double *a)) ;
void rgrid3d_transform_two(rgrid3d *grida, rgrid3d *gridb, void (*operator)(double *a, double *b)) ;
double rgrid3d_integral(const rgrid3d *grid) ;
double rgrid3d_integral_region(const rgrid3d *grid, double xl, double xu, double yl, double yu, double zl, double zu) ;
double rgrid3d_integral_of_square(const rgrid3d *grid) ;
double rgrid3d_integral_of_product(const rgrid3d *grida, const rgrid3d *gridb) ;
double rgrid3d_grid_expectation_value(const rgrid3d *grida, const rgrid3d *gridb) ;
double rgrid3d_grid_expectation_value_func(void *arg, double (*func)(void *arg, double val, double x, double y, double z), const rgrid3d *grida) ;
double rgrid3d_weighted_integral(const rgrid3d *grid, double (*weight)(void *farg, double x, double y, double z), void *farg) ;
double rgrid3d_weighted_integral_of_square(const rgrid3d *grid, double (*weight)(void *farg, double x, double y, double z), void *farg) ;
void rgrid3d_fd_gradient_x(const rgrid3d *grid, rgrid3d *gradient) ;
void rgrid3d_fd_gradient_y(const rgrid3d *grid, rgrid3d *gradient) ;
void rgrid3d_fd_gradient_z(const rgrid3d *grid, rgrid3d *gradient) ;
void rgrid3d_fd_gradient(const rgrid3d *grid, rgrid3d *gradient_x, rgrid3d *gradient_y, rgrid3d *gradient_z) ;
void rgrid3d_fd_laplace(const rgrid3d *grid, rgrid3d *laplace) ;
void rgrid3d_fd_gradient_dot_gradient(const rgrid3d *grid, rgrid3d *grad_dot_grad) ;
void rgrid3d_print(const rgrid3d *grid, FILE *out) ;
void rgrid3d_fft(rgrid3d *grid) ;
void rgrid3d_inverse_fft(rgrid3d *grid) ;
void rgrid3d_scaled_inverse_fft(rgrid3d *grid, double c) ;
void rgrid3d_inverse_fft_norm(rgrid3d *grid) ;
void rgrid3d_fft_convolute(rgrid3d *gridc, const rgrid3d *grida, const rgrid3d *gridb) ;
void rgrid3d_fft_periodic_convolute(rgrid3d *gridc, const rgrid3d *grida, const rgrid3d *gridb) ;
void rgrid3d_fft_nonperiodic_convolute(rgrid3d *gridc, const rgrid3d *grida, const rgrid3d *gridb) ;
double rgrid3d_value_outside_constantdirichlet(const rgrid3d *grid, long i, long j, long k) ;
double rgrid3d_value_outside_neumann(const rgrid3d *grid, long i, long j, long k) ;
double rgrid3d_value_outside_periodic(const rgrid3d *grid, long i, long j, long k) ;
double rgrid3d_value_outside_vortex(const rgrid3d *grid, long i, long j, long k) ;
inline double rgrid3d_value_at_index(const rgrid3d *grid, long i, long j, long k) ;
inline double rgrid3d_value(const rgrid3d *grid, double x, double y, double z) ;
void grid3d_real_to_complex_re(cgrid3d *dest, rgrid3d *source) ;
void grid3d_real_to_complex_im(cgrid3d *dest, rgrid3d *source) ;
void grid3d_add_real_to_complex_re(cgrid3d *dest, rgrid3d *source) ;
void grid3d_add_real_to_complex_im(cgrid3d *dest, rgrid3d *source) ;
void grid3d_product_complex_with_real(cgrid3d *dest, rgrid3d *source) ;
void grid3d_complex_im_to_real(rgrid3d *dest, cgrid3d *source) ;
void grid3d_complex_re_to_real(rgrid3d *dest, cgrid3d *source) ;
void rgrid3d_extrapolate(rgrid3d *dest, rgrid3d *src) ;
void rgrid3d_rotate_z(rgrid3d *out, rgrid3d *in, double th) ;
double rgrid3d_max(rgrid3d *grid) ;
double rgrid3d_min(rgrid3d *grid) ;
void rgrid3d_random(rgrid3d *grid, double scale) ;
inline double rgrid3d_value_at_index_cyl(const rgrid3d *grid, long i, long j, long k) ;
void rgrid3d_product_func_cyl(rgrid3d *grid, double (*func)(void *arg, double r, double phi, double z), void *farg) ;
void rgrid3d_map_cyl(rgrid3d *grid, double (*func)(void *arg, double r, double phi, double z), void *farg) ;
double rgrid3d_integral_cyl(const rgrid3d *grid) ;
double rgrid3d_integral_region_cyl(const rgrid3d *grid, double rl, double ru, double phil, double phiu, double zl, double zu) ;
double rgrid3d_integral_of_square_cyl(const rgrid3d *grid) ;
double rgrid3d_integral_of_product_cyl(const rgrid3d *grida, const rgrid3d *gridb) ;
double rgrid3d_grid_expectation_value_cyl(const rgrid3d *grida, const rgrid3d *gridb) ;
double rgrid3d_grid_expectation_value_func_cyl(void *arg, double (*func)(void *arg, double val, double r, double phi, double z), const rgrid3d *grida) ;
double rgrid3d_weighted_integral_cyl(const rgrid3d *grid, double (*weight)(void *farg, double r, double phi, double z), void *farg) ;
double rgrid3d_weighted_integral_of_square_cyl(const rgrid3d *grid, double (*weight)(void *farg, double r, double phi, double z), void *farg) ;
void rgrid3d_fd_gradient_cyl_r(const rgrid3d *grid, rgrid3d *gradient) ;
void rgrid3d_fd_gradient_cyl_phi(const rgrid3d *grid, rgrid3d *gradient) ;
void rgrid3d_fd_gradient_cyl_z(const rgrid3d *grid, rgrid3d *gradient) ;
void rgrid3d_fd_gradient_cyl(const rgrid3d *grid, rgrid3d *gradient_r, rgrid3d *gradient_phi, rgrid3d *gradient_z) ;
void rgrid3d_fd_laplace_cyl(const rgrid3d *grid, rgrid3d *laplace) ;
inline double rgrid3d_value_cyl(const rgrid3d *grid, double r, double phi, double z) ;
void rgrid3d_extrapolate_cyl(rgrid3d *dest, rgrid3d *src) ;
void rgrid3d_map_cyl_on_cart(rgrid3d *cart, rgrid3d *cyl) ;
void rgrid3d_map_cart_on_cyl(rgrid3d *cyl, rgrid3d *cart) ;
void rgrid3d_add_cyl_on_cart(rgrid3d *cart, rgrid3d *cyl) ;
void rgrid3d_add_cart_on_cyl(rgrid3d *cyl, rgrid3d *cart) ;
void rgrid3d_fftw_alloc(rgrid3d *grid) ;
void rgrid3d_fftw(rgrid3d *grid) ;
void rgrid3d_fftw_inv(rgrid3d *grid) ;
void rgrid3d_fftw_periodic_alloc(rgrid3d *grid) ;
void rgrid3d_fftw_nonperiodic_alloc(rgrid3d *grid) ;
void rgrid3d_fftw_free(rgrid3d *grid) ;
void rgrid3d_fftw_periodic(rgrid3d *grid) ;
void rgrid3d_fftw_periodic_inv(rgrid3d *grid) ;
void grid_threads_init(int threads) ;
int grid_threads() ;
